
Client/Server application to load Big Data ( > 100 mb) file whith data protection

==========================================================================================
Моя первое знакомство и создание структуры WBS.

Описания на английском с временем.
Описание на русском немного подробнее. Но основа одна.

Oleksandr Dehtiar я пример увидел после того как вот это всё понаписывал. Тут не так всё красиво и кратко
как в примере. Но немного я всё таки его подредактировал после того как увидел пример.
Думаю немного надо было короче, надеюсь порядок действий плюс минус понятен.

==========================================================================================

... AND NOW SERIOUSLY !!!

[17 HOURS]			0. Common api for client and server
[7 HOURS]				- Network interface API
	[1 HOUR]				- Initializer (special for windows use WSAStart ...)
	[1 HOUR]				- Cross platform data structure 
	[3 HOURS]				- Skelet function for create socket for server(listen) and client (connect) 
	[1 HOUR]				- Function for get info about server and client(address and port ...) 
	[1 HOUR]				- Close connection client/server 
[10 HOURS]				- Encryption data 
	[5 HOURS]				- Data puck 
	[5 HOURS]				- Data unpuck 
	
[28 HOURS]			1. Server
[2 HOURS] 				- Network layer
	[2 HOUR]				- Initialize server
		[1 HOURS] 				- Create listen socket 
		[1 HOURS] 				- Set socket to accept connection from client 
[6 HOURS] 				- Protocol for speek between client and server 
	[2 HOURS] 				- Request from server to client for send file name list from client work directory 
	[2 HOURS] 				- Get answer from client whith file name list content
	[2 HOURS] 				- Send to client file name what server whant to get
[15 HOURS				- Recive data from client 
	[15 HOURS 				- Multithreding
		[10 HOURS] 				- Thread for recive data from client 
			[5 HOURS] 				- Buffer for recive data 
			[5 HOURS] 				- Counter for check how many data server recive from client 
		[5 HOURS] 				- Thread for unpuck encryption data and save in file 
[3 HOURS] 				- Change connection between client and server 
[2 HOURS] 				- Close connection between client and server

[36 HOURS] 			2. Client
[2 HOURS] 				- Network layer
	[1 HOUR]				- Initialize client 
	[1 HOUR] 				- Connect whith server 
[5 HOURS] 				- Functions for work whith client work directory
	[3 HOURS] 				- Get file name list from client working directory 
	[2 HOURS] 				- Check if file exist in directory
[11 HOURS] 				- Protocol for speek between client and server  
	[2 HOURS] 				- Get request from server for send to server file list 
	[2 HOURS]				- Send list of file to server 
	[2 HOURS] 				- Get request from server for send file 
	[2 HOURS] 				- Send answer whith size file (or answer if file doesn't exist) 
	[3 HOURS] 				- processing server request for change recive port 
[16 HOURS] 				- Send data to server 
	[16 HOURS] 				- Multithreding 
		[8 HOURS] 				- Thread for recive file
			[8 HOURS] 				- Thread for read file in buffer and puck whith encryption 
		[8 HOURS] 				- Send data from buffer to server
[2 HOURS]				- Close connection between client and server

[5 HOURS]			3. CMakeList.txt

==========================================================================================

0. Создать единый интерфейс для платформенно зависимых вызовов. Их имплементацию разделить на два файла. Один под Windows другой под Linux
1. Создать соединение между клиентом и сервером
2. Создать протокол для общения клиента и сервера для отправки запросов
	- запрос списка файлов от сервера
	- ответ клиента со списком файлов 
	- запрос сервера переслать конкретный файл
	- ответ клиента о существовании файла и если таковой имеется передать его размер
	- передача данных
	- сообщение от сервера, что он сменил порт
	- закрытие соединения по окончании передачи
3. Создать механизм кодирования и раскодирования передаваемых данных (шифрование)
	- передача какого то ключа, по которому сервер и клиент смогут расшифровывать данные. (внести в протокол общения).
4. Буфер для предварительного хранения подготовленной информации для отправки клиентом и считывания сервером данных
	- чтение файла в буфер и запись в файл из буфера
	- Обеспечить возможность создания размера буфера и количество буферов. С учетом максимально
		возможного размера отправки тср пакета. Также установить минимальные пределы.
5. Написать функцию для шифрования 
	- зашифровать данные помещенные в буфере предварительно прочитанные из файла перед их отправкой серверу
	- расшифровать данные из буфера, прочитанные от клиента, перед их записью в файл

-- Вариант 1
	Отправлять и считывать данные в одном потоке с использование функции socket select. Но в этом случае при отправке 
	каждого пакета данных мы будем опрашивать socket на наличия в очереди данных для приема. Я считаю этот метод более	
	затратным
-- Вариант 2
	Создать два потока. Один читает данные, другой отправляет. Не тратится время на постоянный опрос и обращение к ядру. Более трудоемкий!

Попробую вариант с многопоточкой!
6. Потоки для клиента
	- основной поток для отправки упакованных данных
		- поток для чтения данных из файла в буффер и их шифрования
		- поток для чтения данных от сервера (ожидание в блокированном вызове recv ...(platform dependent))
7. Потоки для сервера
	- Поток для приема данных от клиента
		- Поток с сокетом который сгенерирован accept для передачи данных 
			между клиентом и сервером. В этом же потоке отправляем запрос на смену порта после 10% и 20%
	- Поток для расшифрования данных и записи в файл
8. Реакция на нестандартное поведение от клиента и сервера

==========================================================================================